#include <Servo.h>
#include <Keypad.h>
#include <math.h>
#include <SoftwareSerial.h> 
#include <DFRobotDFPlayerMini.h>

// --- DFPlayer ---
#define SFX_RX 50
#define SFX_TX 51
SoftwareSerial DFSerial(SFX_RX, SFX_TX);
DFRobotDFPlayerMini myDFPlayer;
byte sfxVolume = 25;

// --- Ø§Ù„ÙƒÙŠØ¨Ø§Ø¯ Ø§Ù„Ù…ÙˆØ­Ø¯ ---
const byte ROWS = 4;
const byte COLS = 4;
char hexaKeys[ROWS][COLS] = {
  {'B','A','D','C'},
  {'6','3','#','9'},
  {'5','2','0','8'},
  {'4','1','*','7'}
}; 
byte rowPins[ROWS] = {44, 45, 46, 47}; 
byte colPins[COLS] = {48, 49, 52, 53};
Keypad customKeypad = Keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS);

// --- LEDs + Buttons Ù„Ù„Ø£Ù„Ø¹Ø§Ø¨ ---
#define LED1_PIN 37
#define BUTTON1_PIN 36
#define LED2_PIN 38
#define BUTTON2_PIN 39
#define LED3_PIN 41
#define BUTTON3_PIN 40
#define LED4_PIN 42
#define BUTTON4_PIN 43

#define NUM_BUTTONS 4
int ledPins[NUM_BUTTONS]   = {LED1_PIN, LED2_PIN, LED3_PIN, LED4_PIN};
int buttonPins[NUM_BUTTONS]= {BUTTON1_PIN, BUTTON2_PIN, BUTTON3_PIN, BUTTON4_PIN};

// --- Ø§Ù„Ù…ÙˆØªÙˆØ± X ---
#define STEP_PIN_X 4
#define DIR_PIN_X 14
#define ENA_PIN_X 2
#define LIMIT_SWITCH_X1 5

// --- Ø§Ù„Ù…ÙˆØªÙˆØ± Y ---
#define STEP_PIN_Y 9
#define DIR_PIN_Y1 8
#define DIR_PIN_Y2 11
#define LIMIT_SWITCH_Y1 22
#define LIMIT_SWITCH_Y2 23

#define STEP_PIN_EXTRA 20
#define DIR_PIN_EXTRA 19
#define EN_PIN_EXTRA 18


#define TRIG_PIN 6
#define ECHO_PIN 12


#define MAX_PATTERN_LENGTH 10
int pattern[MAX_PATTERN_LENGTH];
int patternLength = 4;

int currentLevel = 1;
const int MIN_LEVEL = 1;
const int MAX_LEVEL = 7;

unsigned long interLightDelayMs = 2500; // Ø§Ù„Ø²Ù…Ù† Ø§Ù„ÙƒÙ„ÙŠ Ø¨ÙŠÙ† Ø¨Ø¯Ø§ÙŠØ© ÙƒÙ„ Ø¶Ùˆ ÙˆØ§Ù„ØªØ§Ù„ÙŠ
int onDurationMs = 700;                 // Ù…Ø¯Ø© Ø§Ø´ØªØ¹Ø§Ù„ Ø§Ù„Ø¶Ùˆ (Ù…Ù…ÙƒÙ† ØªØºÙŠÙ‘Ø±ÙŠÙ‡Ø§)
bool requireUniquePattern = true; 

// --- Ø§Ù„Ø³ÙŠØ±ÙÙˆ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ù† 13 ---
Servo servoExtra;  

long readUltrasonicCM() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 20000); // timeout 20ms
  long distance = duration * 0.034 / 2; // cm
  return distance;
}

// --- Ø§Ù„Ø³ÙŠØ±ÙÙˆ ---
Servo servo1;  
Servo servo2;  
Servo servo3;  

// --- RGB RELAY ---
const int R_PIN = 15;
const int G_PIN = 16;
const int B_PIN = 17;
const bool ACTIVE_LOW = true;
int RELAY_ON, RELAY_OFF;

// --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ---
const unsigned int STEP_DELAY_US =350;
int currentMode = 0; // 0=menu, 4=Simon, 5=Random, 9=Robot
int currentX = 0;
int currentY = 0;


// --- Simon Says ---
// const int patternLength = 4;   // Ø·ÙˆÙ„ Ø§Ù„Ù†Ù…Ø· (Ù…Ù…ÙƒÙ† ØªÙƒØ¨Ø±Ùˆ/ØªØµØºØ±Ùˆ)
// int pattern[patternLength];    // Ù…ØµÙÙˆÙØ© Ø§Ù„Ù†Ù…Ø·


// --- Ù…ØªØºÙŠØ±Ø§Øª Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±ÙˆØ¨ÙˆØª ---
bool gameStarted = false;
int selectedLevel = 0;

// ----------------- DFPlayer + LEDs Setup -----------------
void setup() {
  Serial.begin(9600);

  // DFPlayer
  DFSerial.begin(9600);
  if (!myDFPlayer.begin(DFSerial)) {
    Serial.println("DFPlayer Mini not detected!");
    while (true);
  }
  myDFPlayer.volume(sfxVolume);

  // LEDs & Buttons
  for (int i = 0; i < NUM_BUTTONS; i++) {
    pinMode(ledPins[i], OUTPUT);
    pinMode(buttonPins[i], INPUT_PULLUP);
  }

  // Ù…Ø­Ø±ÙƒØ§Øª
  pinMode(STEP_PIN_X, OUTPUT);
  pinMode(DIR_PIN_X, OUTPUT);
  pinMode(ENA_PIN_X, OUTPUT);
  pinMode(LIMIT_SWITCH_X1, INPUT_PULLUP);
  digitalWrite(ENA_PIN_X, LOW);

  pinMode(STEP_PIN_Y, OUTPUT);
  pinMode(DIR_PIN_Y1, OUTPUT);
  pinMode(DIR_PIN_Y2, OUTPUT);
  pinMode(LIMIT_SWITCH_Y1, INPUT_PULLUP);
  pinMode(LIMIT_SWITCH_Y2, INPUT_PULLUP);

  // Ø§Ù„Ù…ÙˆØªÙˆØ± Ø§Ù„Ø¥Ø¶Ø§ÙÙŠ
  pinMode(STEP_PIN_EXTRA, OUTPUT);
  pinMode(DIR_PIN_EXTRA, OUTPUT);
  pinMode(EN_PIN_EXTRA, OUTPUT);

  digitalWrite(EN_PIN_EXTRA, LOW);   // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø§ÙŠÙØ±
  digitalWrite(DIR_PIN_EXTRA, HIGH);  // Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¯ÙˆØ±Ø§Ù†

  servo1.attach(30);
  servo2.attach(31);
  servo3.attach(35);
  servoExtra.attach(13);

  servo1.write(60);
  servo2.write(60);
  servo3.write(0);
  RELAY_ON  = ACTIVE_LOW ? LOW  : HIGH;
  RELAY_OFF = ACTIVE_LOW ? HIGH : LOW;
  pinMode(R_PIN, OUTPUT);
  pinMode(G_PIN, OUTPUT);
  pinMode(B_PIN, OUTPUT);
  setColor(1,1,1);

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  randomSeed(analogRead(0));
  Serial.println("âœ… Ø¬Ø§Ù‡Ø². Ø§Ø¶ØºØ· B Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ùˆ D Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø³Ù….");
  myDFPlayer.play(20);
}


unsigned long lastCheck = 0;
const int CHECK_INTERVAL = 1000; // ÙƒÙ„ 100ms

void checkSafetyStop() {
  if (millis() - lastCheck < CHECK_INTERVAL) return; // Ù…Ø§ ØªÙØ­Øµ Ø¥Ù„Ø§ ÙƒÙ„ 100ms
  lastCheck = millis();

  long d = readUltrasonicCM();
  if (d > 0 && d < 10) {
    while (true) {
      long d2 = readUltrasonicCM();
      if (d2 > 15) break;  // ÙŠØ¸Ù„ ÙˆØ§Ù‚Ù Ù„Ø­Ø¯ Ù…Ø§ ÙŠØ¨Ø¹Ø¯ Ø£ÙƒØªØ± Ù…Ù† 15Ø³Ù…
      delay(50);           // ÙØ­Øµ Ø³Ø±ÙŠØ¹ Ø¨Ø¯ÙˆÙ† Ø¨Ø·Ø¡
    }
  }
}


 void resetRobot() {
    homeX();
    homeY();
    resetServosToStart();
  }

// ----------------- LOOP Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ -----------------
void loop() {
  
  char key = customKeypad.getKey();
  if (key) {
  
    if (key == 'B') {
      currentMode = 0;
      myDFPlayer.play(21);
    }
    else if (key == '4') { currentMode = 4; runSimonSays(); }
    else if (key == '5') { currentMode = 5; runRandomButton(); }

    else if (key == 'D') {
      currentMode = 9;
      startRobotGame();
      
    }
    else if (key == 'C') {
      
      myDFPlayer.play(26); 
      delay(6000);
      resetRobot();
      runRobotSequencecube();
      resetServosToStart();
      
    }

    else if (key == '0') {
           
        // myDFPlayer.play(21);
        resetRobot();
        reverseAllSequences();   // Ø¹ÙƒØ³ ÙƒÙ„ Ø§Ù„ØªØ³Ù„Ø³Ù„Ø§Øª
        resetServosToStart();
      }
  }

}


void setLevelParameters(int level) {
  switch (level) {
    case 1:
      patternLength = 2;
      interLightDelayMs = 2000;
      requireUniquePattern = true;
      break;
    case 2:
      patternLength = 3;
      interLightDelayMs = 1500;
      requireUniquePattern = true;
      break;
    case 3:
      patternLength = 4;
      interLightDelayMs = 1500;
      requireUniquePattern = true;
      break;
    case 4:
      patternLength = 5;
      interLightDelayMs = 1500;
      requireUniquePattern = false; // Ù„Ø£Ù†Ù‡ Ù„Ø§Ø²Ù… ÙŠØ³Ù…Ø­ Ø¨Ø§Ù„ØªÙƒØ±Ø§Ø±
      break;
    case 5:
      patternLength = 6;
      interLightDelayMs = 1200;
      requireUniquePattern = false;
      break;
    case 6:
      patternLength = 7;
      interLightDelayMs = 1000;
      requireUniquePattern = false;
      break;
    case 7:
      patternLength = 8;
      interLightDelayMs = 1000;
      requireUniquePattern = false;
      break;
    default:
      patternLength = 2;
      interLightDelayMs = 2000;
      requireUniquePattern = true;
      break;
  }
}


// ØªÙˆÙ„ÙŠØ¯ Ù†Ù…Ø· Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ (ÙŠÙ…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± Ø¥Ø°Ø§ Ù…Ø·Ù„ÙÙˆØ¨)
void generateRandomPattern() {
  int n = NUM_BUTTONS; // Ù…ÙØªØ±Ø¶ Ù…Ø¹Ø±ÙØ© Ù‡Ø°Ø§ ÙÙŠ ÙƒÙˆØ¯Ùƒ Ø§Ù„Ø£ØµÙ„ÙŠ (Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø²Ø±Ø§Ø±/Ø§Ù„Ø£Ø¶ÙˆØ§Ø¡)
  if (requireUniquePattern && patternLength <= n) {
    // Ø®Ø²Ù† Ø§Ù„Ø£Ù†Ø¯ÙƒØ³Ø§Øª ÙÙŠ pool Ùˆ shuffle Ø«Ù… Ø®Ø° Ø£ÙˆÙ„ patternLength Ø¹Ù†Ø§ØµØ±
    int pool[NUM_BUTTONS];
    for (int i = 0; i < n; i++) pool[i] = i;
    // Fisher-Yates shuffle
    for (int i = n - 1; i > 0; i--) {
      int j = random(i + 1);
      int tmp = pool[i];
      pool[i] = pool[j];
      pool[j] = tmp;
    }
    for (int i = 0; i < patternLength; i++) pattern[i] = pool[i];
  } else {
    // Ù…Ø³Ù…ÙˆØ­ Ø§Ù„ØªÙƒØ±Ø§Ø±
    for (int i = 0; i < patternLength; i++) {
      pattern[i] = random(0, NUM_BUTTONS);
    }
  }
}

// playPattern: ÙŠØ±Ø¬Ø¹ false Ø¥Ø°Ø§ ØªÙ… Ø§Ù„Ø®Ø±ÙˆØ¬ (Ù…Ø«Ù„Ø§Ù‹ Ø¨ÙˆØ§Ø³Ø·Ø© ØªØºÙŠÙŠØ± Ø§Ù„Ù…ÙˆØ¯ Ø¹Ø¨Ø± Ø§Ù„ÙƒÙŠØ¨Ø§Ø¯)
bool playPattern() {
  for (int i = 0; i < patternLength; i++) {
    int ledIndex = pattern[i];
    digitalWrite(ledPins[ledIndex], HIGH);
    delay(onDurationMs);
    digitalWrite(ledPins[ledIndex], LOW);

    unsigned long restDelay = 0;
    if (interLightDelayMs > (unsigned long)onDurationMs) restDelay = interLightDelayMs - onDurationMs;
    else restDelay = 50;

    // Ø§ÙØ­Øµ Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…ÙˆØ¯ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± (Ø¨ÙÙˆØ§ØµÙ„ ØµØºÙŠØ±Ø©) Ø­ØªÙ‰ Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„Ø¥Ù„ØºØ§Ø¡
    unsigned long waited = 0;
    while (waited < restDelay) {
      char key = customKeypad.getKey();
      if (key == '5') { currentMode = 5; return false; }
      else if (key == 'D') { currentMode = 9; return false; }
      else if (key == 'B') { currentMode = 0; return false; }
      delay(50);
      waited += 50;
    }
  }
  return true;
}

// getUserInput -- Ø§Ø³ØªØ®Ø¯Ù…Øª Ù†Ø³Ø®ØªÙƒ Ù…Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø·ÙÙŠÙ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… patternLength Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
bool getUserInput() {
  for (int i = 0; i < patternLength; i++) {
    bool pressedCorrect = false;

    while (!pressedCorrect) {
      for (int b = 0; b < NUM_BUTTONS; b++) {
        int buttonState = digitalRead(buttonPins[b]);

        // âœ¨ Ù…Ù„Ø§Ø­Ø¸Ø©: Ø¥Ø°Ø§ Ø£Ø²Ø±Ø§Ø±Ùƒ Active HIGH ØºÙŠÙ‘Ø± Ø§Ù„Ø´Ø±Ø· Ù„Ù€ (buttonState == HIGH)
        if (buttonState == LOW) {  
          // Serial.print("Button pressed: B");
          // Serial.println(b + 1);

          if (b == pattern[i]) {   // ğŸ”¥ ØµØ§Ø±Øª Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨Ø§Ù„Ø¥Ù†Ø¯ÙƒØ³ Ù…Ø´ Ø±Ù‚Ù… Ø§Ù„Ø¨Ù†
            pressedCorrect = true;
            myDFPlayer.play(4);   // ØµÙˆØª ØµØ­ÙŠØ­

            // Ø§Ù†ØªØ¸Ø± Ø±ÙØ¹ Ø§Ù„Ø¥ØµØ¨Ø¹ Ù‚Ø¨Ù„ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ø²Ø± Ø§Ù„ØªØ§Ù„ÙŠ
            while (digitalRead(buttonPins[b]) == LOW) {
              delay(10);
            }
            delay(200); // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„ØªØ¬Ù†Ø¨ double press
          } else {
            return false;  // Ø¥Ø°Ø§ ØºÙ„Ø· ÙŠÙˆÙ‚Ù
          }
        }
      }
    }
  }
  return true;  // Ø¥Ø°Ø§ Ø®Ù„Øµ Ø§Ù„Ù†Ù…Ø· ÙƒØ§Ù…Ù„ ØµØ­
}


// Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨Ø© (Ø§Ø³ØªØ¨Ø¯Ù„ Ø¨Ù‡Ø§ Ù†Ø³Ø®ØªÙƒ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©)
void runSimonSays() {
  myDFPlayer.play(8); // ØµÙˆØª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
  delay(6500);

  currentLevel = 1;
  setLevelParameters(currentLevel);
  // ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù†Ù…Ø· ÙŠØ®ØªÙ„Ù ÙÙŠ ÙƒÙ„ Ø¬ÙˆÙ„Ø©
  while (currentMode == 4) {
    generateRandomPattern();

    // Ø¹Ø±Ø¶ Ø§Ù„Ù†Ù…Ø·
    bool aborted = !playPattern();
    if (aborted) return;

    myDFPlayer.play(7);
    delay(1000);

    bool success = getUserInput();
    if (currentMode != 4) return;

    myDFPlayer.play(7);
    delay(1000);

    if (success) {
      // Ù†Ù†Ø¬Ø­ -> level up
      // Serial.println("level up");
      setColor(0, 1, 0);
      myDFPlayer.play(3); delay(3500);
      myDFPlayer.play(1); delay(3500);
      delay(3);
      myDFPlayer.play(30);
      delay(3500);
      setColor(1, 1, 1);
      if (currentLevel < MAX_LEVEL) currentLevel++;
      // Ø§Ø¶Ø¨Ø· Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¬Ø¯ÙŠØ¯
      setLevelParameters(currentLevel);
    } else {
      // Ø®Ø·Ø£ -> level down (Ø£Ø¯Ù†Ù‰ Ø­Ø¯ level1)
      setColor(1, 0, 0);
      myDFPlayer.play(5); delay(1500);
      myDFPlayer.play(2); delay(3000);
      setColor(1, 1, 1);
      if (currentLevel > MIN_LEVEL) {
        currentLevel--;
        Serial.print("level down to ");
        Serial.println(currentLevel);
      } else {
        Serial.println("try again - already at minimum level");
      }
      setLevelParameters(currentLevel);
      setColor(1, 1, 1);
    }

    delay(1000); // ÙØ§ØµÙ„ Ù‚Ø¨Ù„ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
  }
}
// ---------------- Ù„Ø¹Ø¨Ø© 5: Random Button ----------------
int streak = 0;                          // Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØµØ­ Ø§Ù„Ù…ØªØªØ§Ù„ÙŠ
unsigned long roundDelay = 3500;         // Ø§Ù„ÙˆÙ‚Øª Ø¨ÙŠÙ† Ø§Ù„ÙƒØ¨Ø³Ø§Øª Ø¨Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ø¨ÙŠÙ† Ø¥Ø¶Ø§Ø¡Ø© ÙˆØ£Ø®Ø±Ù‰)
unsigned long minRoundDelay = 500;      // Ø£Ø³Ø±Ø¹ Ø§Ø´ÙŠ Ù…Ù…ÙƒÙ†
unsigned long maxRoundDelay = 4500;      // Ø£Ø¨Ø·Ø£ Ø§Ø´ÙŠ Ù…Ù…ÙƒÙ†
unsigned long stepChange = 1500;          // Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„ØªØºÙŠÙŠØ± (ÙŠØ²ÙŠØ¯/ÙŠÙ†Ù‚Øµ)

void runRandomButton() {
  myDFPlayer.play(22);
  delay(4000);
  streak = 0;
  roundDelay = maxRoundDelay;

  while (currentMode == 5) {
    char key = customKeypad.getKey();
    if (key == '4') { currentMode = 4; return; }
    else if (key == 'D') { currentMode = 9; return; }
    else if (key == 'B') { currentMode = 0; return; }
    else if (key == 'C') { 
      myDFPlayer.play(26); 
      delay(7000);
      resetRobot(); 
      runRobotSequencecube(); 
      resetServosToStart(); 
     }
    else if (key == '0') { 
      // myDFPlayer.play(21); 
      resetRobot(); 
      reverseAllSequences(); 
      resetServosToStart(); 
    }
    int choice = random(NUM_BUTTONS);
    bool correct = runButtonRound(ledPins[choice], buttonPins[choice], 5000); // timeout Ø«Ø§Ø¨Øª 5 Ø«ÙˆØ§Ù†ÙŠ

    if (correct) {
      streak++;
      if (streak >= 3) {
        if (roundDelay > minRoundDelay + stepChange) {
          roundDelay -= stepChange;   // ÙŠØ®Ù„ÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø¬Ø§ÙŠØ© ØªÙŠØ¬ÙŠ Ø£Ø³Ø±Ø¹
        } else {
          roundDelay = minRoundDelay;
        }

        myDFPlayer.play(30);
        delay(3000);
        // Serial.println(roundDelay);
        streak = 0; // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¹Ø¯
      }
    } else {
      streak = 0;
      if (roundDelay + stepChange <= maxRoundDelay) {
        roundDelay += stepChange;   // ÙŠØ¨Ø·Ø¦ Ø´ÙˆÙŠ
      } else {
        roundDelay = maxRoundDelay;
      }

      Serial.print("â¬‡ï¸ Level Down! Round Delay: ");
      Serial.println(roundDelay);
    }

    delay(roundDelay);  // ğŸŸ¢ Ø§Ù„ÙˆÙ‚Øª Ø¨ÙŠÙ† ÙƒÙ„ ÙƒØ¨Ø³Ø© ÙˆØ§Ù„ØªØ§Ù†ÙŠØ©
  }
}

bool runButtonRound(int ledPin, int buttonPin, unsigned long duration) {
  digitalWrite(ledPin, HIGH);
  setColor(1,1,1);
  unsigned long startTime = millis();
  bool pressedCorrect = false;
  bool pressedWrong = false;

  while (millis() - startTime < duration) {
    char key = customKeypad.getKey();
    if (key == '4') { currentMode = 4; return false; }
    else if (key == 'D') { currentMode = 9; return false; }
    else if (key == 'B') { currentMode = 0; return false; }

    for (int b = 0; b < NUM_BUTTONS; b++) {
      if (digitalRead(buttonPins[b]) == LOW) {
        if (buttonPins[b] == buttonPin) {
          pressedCorrect = true;
          // Serial.println(b+1);
        } else {
          pressedWrong = true;
          // Serial.println(b+1);
        }
        while (digitalRead(buttonPins[b]) == LOW) delay(10);
        goto checkResult;
      }
    }
  }

checkResult:
  digitalWrite(ledPin, LOW);

  if (pressedCorrect) {
    myDFPlayer.play(4);
    delay(1000);
    // setColor(0,1,0);
    return true;
  } else {
    myDFPlayer.play(5);
    delay(1000);
    // setColor(1,0,1);
    return false;
  }
}

// ----------------- Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© -----------------
void setColor(bool r, bool g, bool b) {
  digitalWrite(R_PIN, r ? RELAY_ON : RELAY_OFF);
  digitalWrite(G_PIN, g ? RELAY_ON : RELAY_OFF);
  digitalWrite(B_PIN, b ? RELAY_ON : RELAY_OFF);
}

// ----------------- Ø¯ÙˆØ§Ù„ Ø§Ù„Ø±ÙˆØ¨ÙˆØª -----------------

void moveStepsX(int steps, bool direction) {
  digitalWrite(DIR_PIN_X, direction);
  for (int i = 0; i < steps; i++) {
     checkSafetyStop(); 
    digitalWrite(STEP_PIN_X, HIGH);
    delayMicroseconds(STEP_DELAY_US);
    digitalWrite(STEP_PIN_X, LOW);
    delayMicroseconds(STEP_DELAY_US);
  }
}

void moveStepsY(int steps, bool dirY1, bool dirY2) {
  digitalWrite(DIR_PIN_Y1, dirY1);
  digitalWrite(DIR_PIN_Y2, dirY2);
  for (int i = 0; i < steps; i++) {
    checkSafetyStop(); 
    digitalWrite(STEP_PIN_Y, HIGH);
    delayMicroseconds(STEP_DELAY_US);
    digitalWrite(STEP_PIN_Y, LOW);
    delayMicroseconds(STEP_DELAY_US);
  }
}

// --- Ø§Ù„Ù‡ÙˆÙ…ÙŠÙ†Ø¬ ---
void homeX() {
  digitalWrite(DIR_PIN_X, LOW);
  while (digitalRead(LIMIT_SWITCH_X1) == HIGH) {
    checkSafetyStop(); 
    digitalWrite(STEP_PIN_X, HIGH);
    delayMicroseconds(STEP_DELAY_US);
    digitalWrite(STEP_PIN_X, LOW);
    delayMicroseconds(STEP_DELAY_US);
  }
  currentX = 0;
}

void homeY() {
  digitalWrite(DIR_PIN_Y1, HIGH);
  digitalWrite(DIR_PIN_Y2, LOW);
  while (digitalRead(LIMIT_SWITCH_Y2) == HIGH) {
    checkSafetyStop(); 
    digitalWrite(STEP_PIN_Y, HIGH);
    delayMicroseconds(STEP_DELAY_US);
    digitalWrite(STEP_PIN_Y, LOW);
    delayMicroseconds(STEP_DELAY_US);
  }
  currentY = 0;
}

void liftGripper(){ servo1.write(60); delay(300); }
void lowerGripperToGrab(){ servo1.write(10); delay(300); }
void openGripper(){ servo3.write(40); delay(300); }
void closeGripper(){ servo3.write(0); delay(300); }
void resetServosToStart(){ servo1.write(0); servo2.write(90); servo3.write(60); delay(500); }

void moveTo(int targetX, int targetY) {
  int stepsY = targetY - currentY;
  bool dirY1 = stepsY > 0 ? HIGH : LOW;
  bool dirY2 = stepsY > 0 ? LOW : HIGH;
  moveStepsY(abs(stepsY), dirY1, dirY2);

  int stepsX = targetX - currentX;
  bool dirX = stepsX > 0 ? HIGH : LOW;
  moveStepsX(abs(stepsX), dirX);

  currentX = targetX;
  currentY = targetY;
}

//--- Ø±Ø³Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹ ---
void drawSquare(int startX, int startY, int L,int M) {
  // liftGripper();       
  moveTo(startX, startY); 
  lowerGripperToGrab();   
  moveTo(startX, startY - M);  
  moveTo(startX + L, startY - M); 
  moveTo(startX + L, startY);     
  moveTo(startX, startY);
  moveTo(startX, startY - M);          
  liftGripper(); 
}



// --- Ø±Ø³Ù… Ø®Ø· Ù…Ø§Ø¦Ù„ ---
void drawDiagonalLine(int startX, int startY, int endX, int endY, int steps) {
  lowerGripperToGrab();
  for (int i = 0; i <= steps; i++) {
    int targetX = startX + i * (endX - startX) / steps;
    int targetY = startY + i * (endY - startY) / steps;

    bool dirX = targetX > currentX ? HIGH : LOW;
    bool dirY1 = targetY > currentY ? LOW : HIGH;
    bool dirY2 = targetY > currentY ? HIGH : LOW;

    if (currentX != targetX) moveStepsX(1, dirX);
    if (currentY != targetY) moveStepsY(1, dirY1, dirY2);

    currentX = targetX;
    currentY = targetY;
  }
  // liftGripper();
}



// // --- Ø±Ø³Ù… Ù…Ø«Ù„Ø« ---
void drawTriangle(int X0, int Y0, int X1, int Y1, int steps) {
liftGripper();
moveTo(X0, Y0);
lowerGripperToGrab();
drawDiagonalLine(X0, Y0, X1, Y0, steps);
int midX = (X0 + X1) / 2;
drawDiagonalLine(X1, Y0, midX, Y1, steps);
drawDiagonalLine(midX, Y1, X0, Y0, steps);
drawDiagonalLine(X0, Y0, X1, Y0, steps);//Ù‡Ø§ÙŠ Ø§Ù„ÙÙ†Ø§Ù‡Ø§ Ø¨Ø§Ù„Ø²ÙˆÙ…
liftGripper();
}



void drawHouse(int X0, int Y0, int X1, int Y1, int steps) {
  
liftGripper();
moveTo(X0, Y0);
lowerGripperToGrab();

drawDiagonalLine(X0, Y0, X1, Y0, steps);
int midX = (X0 + X1) / 2;
drawDiagonalLine(X1, Y0, midX, Y1, steps);
drawDiagonalLine(midX, Y1, X0, Y0, steps);

delay(1000);

 moveStepsY(600, HIGH,LOW);
 moveStepsX(2200, HIGH);
 moveStepsY(600, LOW,HIGH);
 moveStepsX(2200, LOW);

liftGripper();


}


// --- ØªØ³Ù„Ø³Ù„ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ---
void runRobotSequence(char shape) {
  resetServosToStart();
  setColor(1, 1, 1); 
  homeY();
  homeX();

  // --- Ø±ÙØ¹ Ø§Ù„Ø³ÙŠØ±ÙÙˆ Ù‚Ø¨Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ØªÙŠØ¨Ø± ---
  servoExtra.write(90);  
  delay(500);  // Ø§Ø¹Ø·ÙŠÙ‡ ÙˆÙ‚Øª ÙŠÙˆØµÙ„ Ù„Ù„Ø²Ø§ÙˆÙŠØ©

  // --- ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ØªÙŠØ¨Ø± ---

  unsigned long startTime = millis(); while (millis() - startTime < 14000) { while (millis() - startTime < 16000) {  digitalWrite(STEP_PIN_EXTRA, HIGH); delayMicroseconds(200); digitalWrite(STEP_PIN_EXTRA, LOW); delayMicroseconds(200); } }

   // --- Ø¥Ù†Ø²Ø§Ù„ Ø§Ù„Ø³ÙŠØ±ÙÙˆ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø³ØªÙŠØ¨Ø± ---
  servoExtra.write(0);  
  delay(500);  


  openGripper();
  servo1.write(70);
  moveStepsX(16000, HIGH);
  servo1.write(27);
  delay(2000);
  closeGripper();
  delay(1000);
  for (int angle = 32; angle <= 65; angle++) {
  servo1.write(angle);
  delay(20); // ÙƒÙ„ Ø¯Ø±Ø¬Ø© ØªØ£Ø®Ø° 20ms
}
  moveStepsX(9500, LOW);
  servo2.write(140);

  if (shape == '1') drawSquare(currentX, currentY, 3000, 600);
  else if (shape == '3') drawTriangle(0, -700, 3000, -100, 2000);
  else if (shape == '2') drawHouse(0, -700, 3000, -100, 2000);
 

  homeY();
  homeX();
  
  
  servo1.write(70);
  servo2.write(90);
  moveStepsX(16000, HIGH);
  servo1.write(27);
  delay(2000);
  openGripper();
  delay(1000);
  for (int angle = 32; angle <= 65; angle++) {
  servo1.write(angle);
  delay(20); // ÙƒÙ„ Ø¯Ø±Ø¬Ø© ØªØ£Ø®Ø° 20ms
}

  homeY();
  homeX();
  
}

///  CUBE GAME

 void liftGripperCube() {
    int currentAngle = servo1.read();
    for (int angle = currentAngle; angle <= 60; angle += 2) {
      servo1.write(angle);
      delay(30);
    }
  }

  void lowerGripperToGrabCube() {
    servo1.write(8);
    delay(300);
  }

  void openGripperCube() {
    servo3.write(60);
    delay(500);
  }

  void closeGripperCube() {
    servo3.write(20);
    delay(500);
  }

   // --- Ø¯Ø§Ù„Ø© ØªØ´ØºÙŠÙ„ ØªØ³Ù„Ø³Ù„ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ ---
void runRobotSequencecube() {
  // Ø¶Ø¨Ø· Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
  // resetServosToStart();
 
  // --- ØªØ³Ù„Ø³Ù„ 1 ---
  myDFPlayer.play(23);
  openGripperCube();
  liftGripperCube();
  moveStepsX(11000, HIGH);
  moveStepsY(1500, LOW, HIGH);
  lowerGripperToGrabCube();
  delay(1000);
  servo1.write(10);
  closeGripperCube();
  delay(2000);
  liftGripperCube();
  homeX();
  moveStepsY(1600, HIGH, LOW);
  lowerGripperToGrabCube();
  delay(2000);
  servo3.write(60);
  delay(1000);
  servo1.write(15);

  // --- ÙØ­Øµ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø­Ù…Ø± Ù„Ù„ØªØ³Ù„Ø³Ù„ 1 ---
  while (true) {
    Serial.println("check_color:1");  // Ø§Ø·Ù„Ø¨ ÙØ­Øµ Ø§Ù„Ø£Ø­Ù…Ø±
    delay(100);  // ÙˆÙ‚Øª Ù‚ØµÙŠØ± Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù€ Pi Ø¨Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
    if (Serial.available() > 0) {
      String feedback = Serial.readStringUntil('\n');
      feedback.trim();
      if (feedback == "all_correct") { 
        setColor(0,1,0);   // Ø£Ø®Ø¶Ø±
        myDFPlayer.play(24);
        delay(2000);
        setColor(1,1,1);
        break;  // Ø§Ù†ØªÙ‚Ù„ Ù„Ù„ØªØ³Ù„Ø³Ù„ Ø§Ù„ØªØ§Ù„ÙŠ
      }
      else{
        setColor(1,0,0);
        myDFPlayer.play(27);
        delay(8000);
      }
    }
  }

  // --- ØªØ³Ù„Ø³Ù„ 2 ---
  homeY();
  homeX();
  liftGripperCube();
  moveStepsX(8300, HIGH);
  moveStepsY(1500, LOW, HIGH);
  lowerGripperToGrabCube();
  delay(1000);
  servo1.write(10);
  closeGripperCube();
  liftGripperCube();
  homeX();
  moveStepsY(1750, HIGH, LOW);
  servo2.write(115);
  lowerGripperToGrabCube();
  delay(2000);
  servo3.write(60);
  delay(1000);
  servo1.write(15);

  // --- ÙØ­Øµ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø²Ø±Ù‚ Ù„Ù„ØªØ³Ù„Ø³Ù„ 2 ---
  while (true) {
    Serial.println("check_color:2");  // Ø§Ø·Ù„Ø¨ ÙØ­Øµ Ø§Ù„Ø£Ø²Ø±Ù‚
    delay(100);
    if (Serial.available() > 0) {
      String feedback = Serial.readStringUntil('\n');
      feedback.trim();
      if (feedback == "all_correct") { 
        setColor(0,1,0);
        myDFPlayer.play(25);
        delay(2000);
        setColor(1,1,1);
        break;
      }
      else{
        setColor(1,0,0);
        myDFPlayer.play(28);
        delay(8000);
      }
    }
  }

  // --- ØªØ³Ù„Ø³Ù„ 3 ---
  homeY();
  homeX();
  liftGripperCube();
  moveStepsX(5700, HIGH);
  moveStepsY(1850, LOW, HIGH);
  lowerGripperToGrabCube();
  delay(1000);
  servo1.write(10);
  delay(700);
  closeGripperCube();
  liftGripperCube();
  homeX();
  moveStepsY(1800, HIGH, LOW);
  servo2.write(145);
  lowerGripperToGrabCube();
  delay(2000);
  servo3.write(60);
  delay(1000);
  liftGripperCube();

  // --- ÙØ­Øµ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£ØµÙØ± Ù„Ù„ØªØ³Ù„Ø³Ù„ 3 ---
  while (true) {
    Serial.println("check_color:3");  // Ø§Ø·Ù„Ø¨ ÙØ­Øµ Ø§Ù„Ø£ØµÙØ±
    delay(100);
    if (Serial.available() > 0) {
      String feedback = Serial.readStringUntil('\n');
      feedback.trim();
      if (feedback == "all_correct") { 
        setColor(0,1,0);
        // myDFPlayer.play(1);
        break;
      }
      else{
        setColor(1,0,0);
        myDFPlayer.play(29);
      }
    }
  }
  myDFPlayer.play(1);
  setColor(1,1,1);
  Serial.println("Ø§Ù†ØªÙ‡Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ³Ù„Ø³Ù„Ø§Øª");
}


  void reverseAllSequences() {
    Serial.println("Ø¨Ø¯Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¹ÙƒØ³ÙŠØ© Ù„ÙƒÙ„ Ø§Ù„Ù…ÙƒØ¹Ø¨Ø§Øª...");

    // --- Ø¹ÙƒØ³ ØªØ³Ù„Ø³Ù„ 1 ---
    moveStepsY(50, LOW, HIGH);
    lowerGripperToGrabCube();
    closeGripperCube();
    liftGripperCube();
    homeY();
    homeX();
    liftGripperCube();
    moveStepsX(11000, HIGH);
    moveStepsY(1600, LOW, HIGH);
    lowerGripperToGrabCube();
    delay(1000);
    servo1.write(10);
    openGripperCube();
    liftGripperCube();
    homeX();
    moveStepsY(1750, HIGH, LOW);
    servo2.write(115);
    delay(1000);

    // --- Ø¹ÙƒØ³ ØªØ³Ù„Ø³Ù„ 2 ---
    lowerGripperToGrabCube();
    delay(1000);
    closeGripperCube();
    liftGripperCube();
    homeY();
    homeX();
    liftGripperCube();
    moveStepsX(8450, HIGH);
    moveStepsY(2000, LOW, HIGH);
    lowerGripperToGrabCube();
    delay(1000);
    servo1.write(10);
    openGripperCube();
    liftGripperCube();
    homeX();
    homeY();
    servo2.write(140);
    servo1.write(0);
    delay(1000);

    // --- Ø¹ÙƒØ³ ØªØ³Ù„Ø³Ù„ 3 ---
    // lowerGripperToGrab();
    closeGripperCube();
    liftGripperCube();
    homeY();
    homeX();
    liftGripperCube();
    moveStepsX(5600, HIGH);
    moveStepsY(2000, LOW, HIGH);
    servo2.write(120);
    lowerGripperToGrabCube();
    delay(1000);
    servo1.write(5);
    openGripperCube();
    liftGripperCube();
    homeX();
    moveStepsY(2000, HIGH, LOW);

    // Serial.println("Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¹ÙƒØ³ÙŠØ©ØŒ ÙƒÙ„ Ø§Ù„Ù…ÙƒØ¹Ø¨Ø§Øª Ø±Ø¬Ø¹Øª Ù„Ù…ÙˆØ§Ù‚Ø¹Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠØ©.");
  }



void startRobotGame() {
  setColor(1,1,1);
  gameStarted = true;
  selectedLevel = 0;
  myDFPlayer.play(16);


  while(currentMode==9){
    char key = customKeypad.getKey();
    if (key) {

      // âœ… Ø²Ø± B Ù„Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø³Ù…
      if (key == 'B') {
        currentMode = 0;   // Ø®Ø±ÙˆØ¬ Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        myDFPlayer.play(21);
        break;
      }
      else if (key == '4') { currentMode = 4; return; }
      else if (key == '5') { currentMode = 5; return; }
      else if (key == 'C') { 
    myDFPlayer.play(26);  
    delay(7000);
    resetRobot(); 
    runRobotSequencecube(); 
    resetServosToStart();
}

     else if (key == '0') { 
      // myDFPlayer.play(21); 
      resetRobot(); 
      reverseAllSequences(); 
      resetServosToStart(); 
    }

      // âœ… Ø²Ø± D Ø¨ÙŠØ±Ø¬Ø¹ ÙŠÙØªØ­ Ù†ÙØ³ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ø¬Ø¯ÙŠØ¯
      if (key == 'D') {
        selectedLevel = 0;
        myDFPlayer.play(16);
      }

      // âœ… Ø§Ø®ØªÙŠØ§Ø± Ù…Ø³ØªÙˆÙ‰ (Ø­ØªÙ‰ Ù„Ùˆ ÙƒÙ†Øª Ø¬ÙˆÙ‡ Ù…Ø³ØªÙˆÙ‰ Ù‚Ø¯ÙŠÙ…)
      if (key=='7'){
        selectedLevel=1;
        myDFPlayer.play(17);
      }
      else if (key=='8'){
        selectedLevel=2;
        myDFPlayer.play(18);
      }

      // âœ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø±Ø³ÙˆÙ…Ø§Øª
      if (selectedLevel==1) {
        if (key=='1') {
          Serial.println(key);
          myDFPlayer.play(11);
          runRobotSequence('1');
        }
        else if (key=='2') {
          myDFPlayer.play(12);
          Serial.println(key);
          runRobotSequence('3');
        }
      }
      else if (selectedLevel==2) {
        if (key=='3') {
          Serial.println(key);
          runRobotSequence('2');
        }
      }

      // âœ… ØªØ°ÙƒÙŠØ± Ø¨Ø¹Ø¯ ÙƒÙ„ Ø±Ø³Ù…Ø©
      if (selectedLevel != 0) {

      }
    }

    // --- Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„ÙÙŠØ¯Ø¨Ø§Ùƒ Ù…Ù† Ø§Ù„Ø±Ø§Ø³Ø¨ÙŠØ±ÙŠ ---
    if (Serial.available() > 0) {
        String feedback = Serial.readStringUntil('\n');
        feedback.trim();
        Serial.println(feedback);  // Debug

        if (feedback == "EXCELLENT") { setColor(0,1,0); myDFPlayer.play(13);delay(3000); setColor(1,1,1);}
        else if (feedback == "GOOD") { setColor(0,0,1); myDFPlayer.play(14); }
        else if (feedback == "RETRY") { setColor(1,0,1); myDFPlayer.play(15);delay(3000); setColor(1,1,1); }
        else setColor(0,0,0);
    }
  }
}

