#كود ديتيكت اللون والمكان
from picamera2 import Picamera2
import cv2
import numpy as np
import time

def is_possible_cube(approx):
    sides = len(approx)
    return 4 <= sides <= 6


picam2 = Picamera2()
picam2.preview_configuration.main.size = (640, 480)
picam2.preview_configuration.main.format = "RGB888"
picam2.set_controls({
    "AwbEnable": False,
    "ExposureTime": 10000,
    "AnalogueGain": 1.0
})
picam2.configure("preview")
picam2.start()
time.sleep(2)


lower_blue = np.array([100, 100, 50])
upper_blue = np.array([130, 255, 255])
lower_red1 = np.array([0, 100, 50])
upper_red1 = np.array([10, 255, 255])
lower_red2 = np.array([160, 100, 50])
upper_red2 = np.array([180, 255, 255])


image_points = np.array([
    [170, 230],
    [194, 64],
    [335, 126],
    [372, 45]
], dtype=np.float32)


table_points = np.array([
    [17.5, 53],
    [18, 25.5],
    [5, 39],
    [0, 23]
], dtype=np.float32)


matrix, status = cv2.findHomography(image_points, table_points)

def pixel_to_cm(x_px, y_px):
    px = np.array([x_px, y_px, 1])
    cm = np.dot(matrix, px)
    cm /= cm[2]
    return cm[0], cm[1]

while True:
    frame = picam2.capture_array()
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

    mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)
    mask_red1 = cv2.inRange(hsv, lower_red1, upper_red1)
    mask_red2 = cv2.inRange(hsv, lower_red2, upper_red2)
    mask_red = cv2.bitwise_or(mask_red1, mask_red2)

    for color, mask, color_bgr in [
        ("Blue", mask_blue, (255, 0, 0)),
        ("Red", mask_red, (0, 0, 255))
    ]:
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area > 200:
                approx = cv2.approxPolyDP(cnt, 0.02 * cv2.arcLength(cnt, True), True)
                if is_possible_cube(approx):
                    x, y, w, h = cv2.boundingRect(approx)
                    center_x = x + w // 2
                    center_y = y + h // 2

                    # ????? ?? ???? ??? ??
                    cm_x, cm_y = pixel_to_cm(center_x, center_y)

                    cv2.drawContours(frame, [approx], -1, color_bgr, 2)
                    cv2.circle(frame, (center_x, center_y), 5, (255, 255, 255), -1)

                    text = f"{color}: px({center_x},{center_y}) cm({cm_x:.1f},{cm_y:.1f})"
                    cv2.putText(frame, text, (x, y - 10),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.5, color_bgr, 2)

                    print(text)

 
    height, width, _ = frame.shape
    cv2.rectangle(frame, (0, 0), (width - 1, height - 1), (0, 255, 255), 2)
    cv2.putText(frame, "(0, 0)", (5, 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
    cv2.putText(frame, f"({width - 1}, 0)", (width - 110, 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
    cv2.putText(frame, f"(0, {height - 1})", (5, height - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
    cv2.putText(frame, f"({width - 1}, {height - 1})", (width - 140, height - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)

    cv2.imshow("Detection", frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

picam2.stop()
cv2.destroyAllWindows()

